# Docker For Beginners.

## 13 команд для Docker часто встречающихся. Поехали.
1. **docker ps** — показывает список запущенных контейнеров. Некоторые из полезных флагов:
- -a / --all — список всех контейнеров (по умолчанию показывает только запущенные);
- -q / --quiet — перечислить только id контейнеров (полезно, когда вам нужны все контейнеры).

2. **docker pull** — большинство образов создаётся на основе базового образа из Docker Hub. Docker Hub содержит множество готовых образов, которые можно использовать вместо того, чтобы создавать и настраивать свой собственный. Чтобы скачать определённый образ или набор образов (репозиторий), используйте команду docker pull.
3. **docker build** — эта команда собирает образ Docker из Dockerfile и «контекста». Контекст сборки — это набор файлов, расположенных по определённому пути или URL. Используйте флаг -t, чтобы задать имя образа. Например, команда docker build -t my_container . соберёт образ, используя текущую директорию, на что указывает точка в конце.
4. **docker run** — запускает контейнер, на основе указанного образа. Эту команду можно дополнять другими, например, docker run my_image -it bash запустит контейнер, а затем запустит в нём bash.
5. **docker logs** — эта команда используется для просмотра логов указанного контейнера. Можно использовать флаг --follow, чтобы следить за логами работающей программы: docker logs --follow my_container.
6. **docker volume ls** — показывает список томов, которые являются предпочитаемым механизмом для сохранения данных, генерируемых и используемых контейнерами Docker. **docker volume prune** удаляет все тома, если docker volume rm то удаляет один и более томов перечисленных в команде.
7. **docker rm** — удаляет один и более контейнеров, например, docker rm my_container.
8. **docker rmi** — удаляет один и более образов, например, docker rmi my_image.
9. **docker stop** — останавливает один и более контейнеров, **docker start** соответсвенно запускает остановленный контейнер. Команда docker stop my_container остановит один контейнер, а docker stop $(docker ps -a -q) — все запущенные. Более грубый способ — использовать docker kill my_container, который не пытается сначала аккуратно завершить процесс.
10. Можно комбинировать эти команды. Например, для очистки всех контейнеров и образов:
- Останавливаем все запущенные контейнеры **docker kill $(docker ps -q)**.
- Удаляем все остановленные контейнеры **docker rm $(docker ps -a -q)**.
- Удаляем все образы **docker rmi $(docker images -q)**.
11. **docker attach** - Присоединение к работающему контейнеру.
12. **docker commit** - ``` docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]] ```  Создает новый образ из изменений контейнера.
13. **docker images** - Выводит список образов. Если указать название REPOSITORY, например docker images python то выводит образ Python.

Существует гораздо больше команд для Docker, о которых можно почитать в документации. Пробуйте новые примеры, комбинируйте их, и скоро это войдёт в привычку.

### Основные концепции Docker на простых примерах из жизни
Контейнеры чрезвычайно полезны с точки зрения безопасности, воспроизводимости и масштабируемости при разработке ПО и обработке данных. Их использование облегчает жизнь многим разработчикам.

Для разработки, упаковки и запуска приложений в контейнере необходимо специальное ПО. Docker — одно из самых популярных решений для работы с контейнерами.
#### На что это похоже?
Docker-контейнер может быть рассмотрен как программа. То есть Docker-контейнер — это набор инструкций, который управляет другими кусочками механизма.
Пока Docker-контейнер работает, действует некая программа, запущенная внутри него. Например, код в Docker может отправлять вам содержимое страницы, которую вы просматриваете прямо сейчас. Или брать вашу голосовую команду для Amazon Alexa и декодировать её, чтобы использовать в другой программе в другом Docker.
С Docker вы можете запускать несколько контейнеров одновременно. В конце концов Docker, как любая другая программа, может быть запущен, проверен, остановлен и удалён.
# Некоторые термины
**Виртуальная машина**
Docker чем-то схож с виртуальной машиной. Но всё же это больше средство виртуализации процессов, а не систем.
**Образ**
Docker-образы похожи на чертежи или формочки для выпечки. Это некий шаблон, который помогает воспроизводить одинаковый результат.
Образ содержит в себе Docker-файл, все необходимые зависимости для вашего приложения и непосредственно само ваше приложение.
**Docker-файл**
Docker-файл — инструкции для Docker по настройке и запуску приложений. В Docker-файле находится описание базового образа, на котором построен контейнер. Одни из самых популярных образов — Python, Ubuntu и Alpine.
С помощью дополнительных слоёв в Docker-файле можно добавить необходимое ПО. Например, можно указать, что Docker’у нужно добавить библиотеки NumPy, Pandas и Scikit-learn.
**Docker-контейнер**
Docker-образ плюс команда **docker run image_name** создадут и запустят контейнер по образу.
**Реестр контейнеров**
Если вы хотите, чтобы и другие люди могли создавать контейнеры по вашему образу, вы можете отправить свой образ в реестр контейнеров. Docker Hub — самый большой и чаще всего используемый реестр.
# Основные термины Docker
**Термины**
Все термины для лучшего восприятия разделены на две группы: базовые термины (те, с которыми вы столкнётесь в первую очередь) и термины в контексте масштабирования (пригодятся при использовании нескольких контейнеров одновременно).
### Базовые термины
**Docker-платформа** — программа, обеспечивающая возможность упаковки и запуска приложения в контейнере на любом Linux сервере. Она собирает код и зависимости. Благодаря хорошей мобильности и воспроизводимости это упрощает масштабирование.
**Docker-движок** — клиент-серверное приложение. Docker Community Edition (CE) — бесплатная версия и, скорее всего, вы будете использовать именно её. Docker Enterprise — платный продукт, он поставляется с дополнительными функциями поддержки, управления и безопасности.
Docker-клиент — основной способ взаимодействия с Docker’ом. При использовании Docker Command Line Interface (CLI) вы просто вводите в терминал нужную команду, которая обычно начинается со слова docker. Затем Docker-клиент использует Docker API для отправки команды на Docker Daemon.
**Docker Daemon** — Docker-сервер, отвечающий на Docker API запросы. Он управляет образами, контейнерами, Docker-сетями и тома Docker.
**Docker тома (Volumes)** — предпочтительный механизм для хранения используемых и генерируемых вашим приложением данных.
**Docker-реестр** — удалённое место, где содержатся все Docker-образы. Вы загружаете туда образы или, наоборот, скачиваете их оттуда. Можно использовать как ваш собственный реестр, так и реестр любого провайдера. Например, AWS или Google Cloud.
**Docker Hub** — пожалуй, самый известный и крупный Docker-реестр. Там вы сможете найти нужный вам образ или загрузить ваш собственный — всё это бесплатно.
**Docker-репозиторий** — собрание Docker-образов с одинаковыми названиями, но с разными тегами. Тег — это идентификатор Docker-образа. Обычно в репозитории содержатся разные версии одного и того же образа. К примеру, Python — название одного из самых популярных Docker-репозиториев на Docker Hub-е. Python:3.7-slim относится к версии Python-образа с тегом 3.7-slim в Python репозитории. В реестр можно загружать как целый репозиторий, так и один образ.
### Масштабирование контейнеров
**Docker Compose** — инструмент, который упрощает запуск приложения, использующего несколько контейнеров. Он позволяет вам добавлять команды для повторного использования в специальный файл — docker-compose.yml. Интерфейс Docker Compose command line упростит взаимодействие с вашим мультиконтейнерным приложением. К тому же Docker Compose предоставляется бесплатно вместе с установщиком Docker.
**Docker-сервисы** — разные части приложения. Из официальной документации:

>Docker-сервисы — это «контейнеры в продакшене». Сервис запускает и конфигурирует образ: >указывает используемые порты, сколько реплик контейнера запустить и т. д. Увеличение >количества сервисов увеличивает число экземпляров контейнера, выполняющих эту часть >программы, но при этом затрачивается намного больше ресурсов.

**Docker-сервисы** позволяют вам масштабировать контейнеры между несколькими Docker Daemons, а также использовать Docker Swarms
**Docker Swarm (рой)** — инструмент для оркестрирования (управления) развёртывания вашего приложения. Официальный Docker-туториал научит вас им пользоваться
# Кратко о каждом термине
### Базовые термины
- Docker-платформа — программа, запускающая приложение.
- Docker-движок — клиент-серверное  приложение (Community Edition или Docker Enterprise).
- Docker-клиент — оперирует Docker CLI для взаимодействия с Docker Daemon.
- Docker Daemon — Docker-сервер управляющий ключевыми функциями.
- Docker тома (Volumes) — хранилище данных для приложения.
- Docker-реестр — удалённое хранилище образов.
- Docker Hub — самый популярный Docker-реестр.
- Docker-репозиторий — несколько сгруппированных образов, например Alpine.
### Масштабирование контейнеров
- Docker-сеть — соединяет контейнеры вместе.
- Docker Compose — помогает сэкономить время при создании мульти-контейнерных приложений.
- Docker Swarm — оркестрация развёртывания приложения.
- Docker-сервисы — контейнеры в продакшене.
### Немного о Kubernetes
**Kubernetes** — автоматизирует процесс развёртывания, масштабирования и управления контейнерами приложений. Вместо Docker Swarm можно использовать Kubernetes. Правда он не является официальной частью Doker’а, Kubernetes больше похож на Docker BFF.
# Еще немного о Docker
### Docker-образы
Docker-образ создаётся во время сборки, а Docker-контейнер — во время запуска приложения.
Docker-файл — сердце Docker’а. Он указывает Docker’у как построить образ, который будет использоваться при создании контейнера.
Каждый Docker-образ содержит файл с именем Dockerfile (он без расширения). При вызове docker build предполагается, что Dockerfile будет находиться в текущей рабочей директории. Но с помощью флага -f можно указать другое расположение.
Контейнер состоит из ряда слоёв. Все слои доступны только для чтения, кроме последнего – он располагается над остальными. Docker-файл указывает порядок добавления слоёв.
Каждый слой — это просто файл с изменением предыдущего слоя. В Unix практически всё является файлом.
Базовый слой, его ещё называют родительским, – это начальный слой.
При загрузке Docker-образа из удалённого репозитория скачиваются только отсутствующие у вас слои. Docker экономит место и время, повторно используя уже существующие слои.
Инструкция Docker-файла — слово в верхнем регистре, которое стоит перед аргументом какой-либо команды. Каждая строка в Docker-файле может содержать инструкцию, все они обрабатываются сверху вниз. Инструкции выглядят так:

```
FROM ubuntu:18.04
COPY . /app
```
И только инструкции FROM, RUN, COPY и ADD создают слои в конечном образе. Другие инструкции производят настройку, добавляют метаданные или же просто говорят Docker’у сделать что-либо во время запуска (например открыть порт или выполнить команду).
Эта статья предполагает использование Unix Docker-образа. Вы, конечно, можете использовать и Windows Docker-образ, но он медленнее, менее удобный и, вообще, его не часто применяют. Так что, пользуйтесь Unix по возможности.

## Несколько Docker-инструкций
- FROM — задаёт родительский (главный) образ;
- LABEL — добавляет метаданные для образа. Хорошее место для размещения информации об авторе;
- ENV — создаёт переменную окружения;
- RUN — запускает команды, создаёт слой образа. Используется для установки пакетов и библиотек внутри контейнера;
- COPY — копирует файлы и директории в контейнер;
- ADD — делает всё то же, что и инструкция COPY. Но ещё может распаковывать локальные .tar файлы;
- CMD — указывает команду и аргументы для выполнения внутри контейнера. Параметры могут быть переопределены. Использоваться может только одна инструкция CMD;
- WORKDIR — устанавливает рабочую директорию для инструкции CMD и ENTRYPOINT;
- ARG — определяет переменную для передачи Docker’у во время сборки;
- ENTRYPOINT — предоставляет команды и аргументы для выполняющегося контейнера. Суть его несколько отличается от CMD, о чём мы поговорим ниже;
- EXPOSE — открывает порт;
- VOLUME — создаёт точку подключения директории для добавления и хранения постоянных данных.

**Инструкции и примеры к ним**
Docker-файл чисто теоретически может содержать только одну строчку:
```
FROM ubuntu:18.04
```
### FROM
Docker-файл должен начинаться с инструкции FROM или ARG, за которой следует FROM. Команда FROM говорит Docker’у использовать базовый образ, который соответствует репозиторию и тегу.
В этом примере хранилище образов — Ubuntu. Ubuntu — название официального Docker-репозитория, в котором и содержится данная ОС.
Заметьте, что этот Docker-файл содержит тег для базового образа: 18.04, который указывает Docker’у, какую именно версию образа нужно использовать. Если тег не указан, по умолчанию берётся последняя версия образа. Но лучше всё же указывать тег базового образа. Когда Docker-файл, приведённый выше, используется для создания локального Docker-образа впервые, он загружает слои, указанные в образе Ubuntu.
При создании Docker-контейнера, вы помещаете наверх слой, который впоследствии можно будет изменить.
### Подробнее про Docker-файл
Кроме того, что ваш однострочный образ сжат, он ещё и медленный, предоставляет мало информации и ничего не делает во время запуска контейнера. Посмотрите на более длинный Docker-файл, который запускает более легковесный образ, а также выполняет скрипт во время запуска.
```
FROM python:3.7.2-alpine3.8
LABEL maintainer="jeffmshale@gmail.com"
ENV ADMIN="jeff"
RUN apk update && apk upgrade && apk add bash
COPY . ./app
ADD https://raw.githubusercontent.com/discdiver/pachy-vid/master/sample_vids/vid1.mp4 \
/my_app_directory
RUN ["mkdir", "/a_directory"]
CMD ["python", "./my_script.py"]

```
### Важно : 
Хочу заметить, что в Docker fail нужно учитывать **пробелы**.

Но что же это всё обозначает?
В роли базового образа выступает официальный Python-образ с тегом 3.7.2-alpine3.8. Как вы можете увидеть из исходников, образ включает в себя Linux, Python и ничего более. Alpine-образы очень популярны, потому что они маленькие, быстрые и безопасные. Однако Alpine-образы не поставляются сразу со всеми компонентами, характерными для вашей ОС. Некоторые пакеты вам придётся установить самостоятельно.
### LABEL
Следующая инструкция — LABEL. LABEL добавляет метаданные к образу, предоставляет контактную информацию. Она не замедляет процесс запуска и не занимает много места, наоборот, обеспечивает образ полезной информацией, так что обязательно используйте её. Больше про LABEL читайте здесь.
### ENV
ENV создаёт переменную окружения, которая становится доступной во время запуска контейнера. В примере выше вы могли видеть использование переменной ADMIN при создании контейнера.
ENV удобна для обозначения констант. Если константа используется в нескольких местах файла Dockerfile, и вам понадобится изменить её значение позднее, это можно будет сделать в одном месте.
**Docker-файл** зачастую предоставляет несколько путей решения одной задачи. Будет хорошо, если в вашем решении будет учитываться баланс Docker-соглашений, прозрачность и скорость. К примеру, RUN, CMD и ENTRYPOINT служат различным целям и могут использоваться для выполнения команд.
### RUN
RUN создаёт слой во время запуска. Docker фиксирует состояние образа после каждой инструкции RUN.
Чаще всего используется для установки нужных пакетов внутрь контейнера. В примере выше RUN apk update && apk upgrade говорит Docker’у обновить пакеты из базового образа. && apk add bash указывает на то, что для базового образа нужно установить bash.
apk — это сокращение от Alpine Linux package manager. Если вы используете базовый образ не Alpine Linux, то установка пакетов производится командой RUN apt-get.
RUN и её родственные инструкции: CMD, ENTRYPOINT — могут быть как форме оболочки, так и в форме shell-скрипта. Во втором случае используют JSON-синтаксис: RUN ["my_executable", "my_first_param1", "my_second_param2"]. А в примере выше использовалась форма оболочки: RUN apk update && apk upgrade && apk add bash.
Позднее в вашем Docker-файле вы будете создавать новую директорию, используя ["mkdir", "/a_directory"]. Не забывайте, что в JSON нужно использовать двойные кавычки!
### COPY
Инструкция COPY . ./app говорит Docker’у, что нужно скопировать файлы и папки из вашей локальной сборки в рабочую директорию образа. COPY создаст все нужные папки, если они отсутствуют.
### ADD
ADD делает то же самое, что и COPY, но с двумя отличиями. ADD может загружать файлы по URL, а также извлекать локальные TAR-файлы.
В примере выше ADD копировала файлы по URL внутрь директории контейнера. Но официальныя документация не рекомендует использовать ADD так, потому что потом вы попросту не сможете удалить файлы. А дополнительные файлы увеличивают размер образа.
Ещё официальная документация для ясности рекомендует использовать, когда это возможно, COPY вместе ADD. Жаль только, что в Docker’е невозможно использовать ADD и COPY в одной команде.
Заметьте, инструкция содержит символ \. Это нужно для лучшей читаемости – так вы разбиваете длинную инструкцию на несколько строк.
### CMD
CMD — инструкция для запуска чего-либо во время запуска самого контейнера. По ходу сборки она не фиксирует никакого результата. В примере выше во время сборки запускался скрипт my_script.py.
Ещё пара моментов о CMD:
Только одна CMD-инструкция на весь Docker-файл. Иначе все кроме последней будут проигнорированы;
CMD может включать исполняемый файл;
Если же CMD не содержит никакого файла, обязательно должна быть инструкция ENTRYPOINT. В этом случает обе инструкции должны быть в формате JSON;
Аргументы командной строки для запуска Docker переопределяют аргументы, предоставленные CMD в Docker-файле.
**В следующем примере представлены ещё несколько Docker-инструкций:**
```
FROM python:3.7.2-alpine3.8
LABEL maintainer="jeffmshale@gmail.com"

# Install dependencies
RUN apk add --update git

# Set current working directory
WORKDIR /usr/src/my_app_directory

# Copy code from your local context to the image working directory
COPY . .

# Set default value for a variable
ARG my_var=my_default_value

# Set code to run at container run time
ENTRYPOINT ["python", "./app/my_script.py", "my_var"]

# Expose our port to the world
EXPOSE 8000

# Create a volume for data storage
VOLUME /my_volume
```
В Docker-файле вы можете добавлять комментарии. Комментарии начинаются со знака #.
Обычно установка пакетов — приоритетная задача для Docker’а. Как говорилось ранее, есть несколько способов загрузки пакетов при помощи инструкции RUN.
Для Alpine Docker-образа вы используете apk. apk для типичной Linux-сборки — apt-get. Например, пакеты для базового Ubuntu-образа могут быть установлены и обновлены так: RUN apt-get update && apt-get install my_package.
В дополнение к apk и apt-get, Python-пакеты могут быть установлены через pip, wheel и conda. Методы варьируются в зависимости от языка.
Нижележащие слои должны предоставить свое средство установки и управления пакетами. Если возникнет проблема с установкой пакетов, убедитесь, что у вас установлен менеджер пакетов.
Можно использовать RUN вместе с pip и списком нужных пакетов. Для этого объедините команды установки пакетов в одну инструкцию и разделите их символом продолжения строки (\). Этот метод позволяет улучшить читаемость и уменьшить количество слоев (из-за отсутствия возможности использовать несколько RUN инструкций).
Также вы можете запустить установщик, указав ему файл, содержащий все зависимости для вашего образа. Обычно он называется requirements.txt.
### WORKDIR
Меняет текущую рабочую директорию в контейнере для инструкций: COPY, ADD, RUN и ENTRYPOINT.
##### Несколько замечаний:
- Предпочтительно задать абсолютный путь с помощью WORKDIR, а не перемещаться по файловой системе с помощью команд cd в Docker-файле;
- WORKDIR автоматически создаёт директорию, если её ещё нет;
- Можно использовать несколько WORKDIR-инструкций. Если используются относительные пути — каждая инструкция поменяет рабочую директорию.
### ARG
Определяет переменную для передачи из командной строки в образ. Для ARG можно указать значение по умолчанию: **ARG my_var=my_default_value**.
В отличие от ENV-переменных, ARG-переменные не доступны для запущенных контейнеров. Однако вы можете использовать их для установки дефолтных значений для ENV-переменных, когда вы создаёте образ. И затем ENV-переменные сохраняются. Больше про это вы найдёте здесь.
### ENTRYPOINT
ENTRYPOINT тоже позволяет вам задавать дефолтные команды и аргументы во время запуска контейнера. Она похожа на CMD, но параметры ENTRYPOINT не переопределяются, если контейнер запущен с параметрами командной строки.
Вместо этого аргументы командной строки, передаваемые docker run myimagename, добавляются к аргументам инструкции ENTRYPOINT. Например, docker run my_image bash добавляет аргумент bash в конец, ко всем другим аргументам ENTRYPOINT.
**Docker-файл** обязательно должен содержать либо CMD-инструкцию, либо ENTRYPOINT-инструкцию.
В официальной документации есть несколько советов, которые помогут сделать выбор между CMD и ENTRYPOINT для начальной команды:
- Если вам нужно запускать одну и туже команду несколько раз, выбирайте ENTRYPOINT;
- Используйте ENTRYPOINT, когда ваш контейнер выступает в роли исполняющейся программы;
- При наличии дополнительных дефолтных аргументов, которые могут быть изменены через командную строку, лучше подойдёт CMD.

Впримере выше, ENTRYPOINT ["python", "my_script.py", "my_var"] запускает в контейнере Python-скрипт my_script.py с аргументом my_var. Затем переменная my_var может быть использована в my_script argparse. Заметьте, у my_var есть дефолтное значение, ранее установленное в Docker-файле при помощи ARG. Так что, если аргумент не будет задан через командную строку, возьмётся его значение по умолчанию.
Как правило, Docker рекомендует вам использовать исполняемую форму с JSON-синтаксисом ENTRYPOINT ["executable", "param1", "param2"].
### EXPOSE
Инструкция EXPOSE показывает, какой порт пробрасывать из контейнера.
Используйте команду **docker run с флагом -p** для пробрасывания и сопоставления нескольких портов во время запуска. Флаг в верхнем регистре -P будет пробрасывать все открытые порты.
### VOLUME
VOLUME определяет, где контейнер будет хранить постоянные данные и получать к ним доступ.

### Подробнее о Docker Compose
Docker Compose — это инструментальное средство, входящее в состав Docker. Оно предназначено для решения задач, связанных с развёртыванием проектов.
Изучая основы Docker, вы могли столкнуться с созданием простейших приложений, работающих автономно, не зависящих, например, от внешних источников данных или от неких сервисов. На практике же подобные приложения — редкость. Реальные проекты обычно включают в себя целый набор совместно работающих приложений.
Как узнать, нужно ли вам, при развёртывании некоего проекта, воспользоваться Docker Compose? На самом деле — очень просто. Если для обеспечения функционирования этого проекта используется несколько сервисов, то Docker Compose может вам пригодиться. Например, в ситуации, когда создают веб-сайт, которому, для выполнения аутентификации пользователей, нужно подключиться к базе данных. Подобный проект может состоять из двух сервисов — того, что обеспечивает работу сайта, и того, который отвечает за поддержку базы данных.
**Технология Docker Compose, если описывать её упрощённо, позволяет, с помощью одной команды, запускать множество сервисов**.

##### Разница между Docker и Docker Compose

Docker применяется для управления отдельными контейнерами (сервисами), из которых состоит приложение.
Docker Compose используется для одновременного управления несколькими контейнерами, входящими в состав приложения. Этот инструмент предлагает те же возможности, что и Docker, но позволяет работать с более сложными приложениями.

#### Типичный сценарий использования Docker Compose

Docker Compose — это, в умелых руках, весьма мощный инструмент, позволяющий очень быстро развёртывать приложения, отличающиеся сложной архитектурой. Сейчас мы рассмотрим пример практического использования Docker Compose, разбор которого позволит вам оценить те преимущества, которые даст вам использование Docker Compose.
Представьте себе, что вы являетесь разработчиком некоего веб-проекта. В этот проект входит два веб-сайта. Первый позволяет людям, занимающимся бизнесом, создавать, всего в несколько щелчков мышью, интернет-магазины. Второй нацелен на поддержку клиентов. Эти два сайта взаимодействуют с одной и той же базой данных.
Ваш проект становится всё популярнее, и оказывается, что мощности сервера, на котором он работает, уже недостаточно. В результате вы решаете перевести весь проект на другую машину.
К сожалению, нечто вроде Docker Compose вы не использовали. Поэтому вам придётся переносить и перенастраивать сервисы по одному, надеясь на то, что вы, в процессе этой работы, ничего не забудете.
Если же вы используете Docker Compose, то перенос вашего проекта на новый сервер — это вопрос, который решается выполнением нескольких команд. Для того чтобы завершить перенос проекта на новое место, вам нужно лишь выполнить кое-какие настройки и загрузить на новый сервер резервную копию базы данных.

##### Вообщем после того, как вы собрали Docker compose.yml вам будет полезно знать:

**Собрать проект командой:**
```$ docker-compose build```
**Запустить проект**
```$ docker-compose up```

##### Полезные команды
Рассмотрим некоторые команды, которые могут вам пригодиться при работе с Docker Compose.

Эта команда позволяет останавливать и удалять контейнеры и другие ресурсы, созданные командой **docker-compose up:**

```$ docker-compose down```

Эта команда выводит журналы сервисов:

```$ docker-compose logs -f [service name]```

Например, в нашем проекте её можно использовать в таком виде: **$ docker-compose logs -f [service name].**

С помощью такой команды можно вывести список контейнеров:

```$ docker-compose ps```

Данная команда позволяет выполнить команду в выполняющемся контейнере:

```$ docker-compose exec [service name] [command]```

Например, она может выглядеть так: **docker-compose exec server ls.**

Такая команда позволяет вывести список образов:

```$ docker-compose images```

### Заключение
Не были упомянуты такие инструкции, как USER, ONBUILD, STOPSIGNAL, SHELL, и HEALTHCHECK, но обязательно в скором будущем добавлю.))



